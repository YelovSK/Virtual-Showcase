// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInit

// Inputs
RWTexture2D<float4> InputImage;
uint Hue;
uint HueThreshold;
uint StartX;
uint StartY;
float4 InRangeColor;

// Outputs
RWStructuredBuffer<uint> ColorCounter;

// Constants
static const float MIN_VALUE = 0.2;
static const float MIN_SATURATION = 0.3;

float3 rgb_to_hsv_no_clip(float3 RGB)
{
    float3 HSV;

    float min_channel;
    float max_channel;

    if (RGB.x > RGB.y)
    {
        max_channel = RGB.x;
        min_channel = RGB.y;
    }
    else
    {
        max_channel = RGB.y;
        min_channel = RGB.x;
    }

    if (RGB.z > max_channel) max_channel = RGB.z;
    if (RGB.z < min_channel) min_channel = RGB.z;

    HSV.xy = 0;
    HSV.z = max_channel;

    const float delta = max_channel - min_channel;

    if (delta != 0)
    {
        HSV.y = delta / HSV.z;
        const float3 delta_RGB = (HSV.zzz - RGB + 3 * delta) / (6.0 * delta);

        if (RGB.x == HSV.z)
        {
            HSV.x = delta_RGB.z - delta_RGB.y;
        }
        else if (RGB.y == HSV.z)
        {
            HSV.x = (1.0 / 3.0) + delta_RGB.x - delta_RGB.z;
        }
        else if (RGB.z == HSV.z)
        {
            HSV.x = (2.0 / 3.0) + delta_RGB.y - delta_RGB.x;
        }
    }

    return HSV;
}

[numthreads(1, 1, 1)]
void CSInit(uint3 id : SV_DispatchThreadID)
{
    ColorCounter[0] = 0;
}

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const float2 pos = float2(id.x + StartX, id.y + StartY);

    const float4 color = InputImage[pos];
    const float3 hsv = rgb_to_hsv_no_clip(color.rgb);

    const float hue = hsv.x * 360.0f;
    const float saturation = hsv.y;
    const float value = hsv.z;

    // Dark or unsaturated colors are meh.
    if (value < MIN_VALUE || saturation < MIN_SATURATION)
    {
        return;
    }

    int difference = abs(Hue - hue);
    if (difference > 180)
    {
        difference = 360 - difference;
    }

    if (difference <= HueThreshold)
    {
        InputImage[pos] = InRangeColor;
        InterlockedAdd(ColorCounter[0], 1);
    }
}