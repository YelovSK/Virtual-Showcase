// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInit

// Inputs
RWTexture2D<float4> InputImage;
uint Hue;
uint HueThreshold;
uint StartX;
uint StartY;
uint EndX;
uint EndY;
float4 InRangeColor;

// Outputs
RWStructuredBuffer<uint> ColorCounter;

float3 rgb_to_hsv_no_clip(float3 RGB)
{
    float3 HSV;

    float minChannel, maxChannel;
    if (RGB.x > RGB.y)
    {
        maxChannel = RGB.x;
        minChannel = RGB.y;
    }
    else
    {
        maxChannel = RGB.y;
        minChannel = RGB.x;
    }

    if (RGB.z > maxChannel) maxChannel = RGB.z;
    if (RGB.z < minChannel) minChannel = RGB.z;

    HSV.xy = 0;
    HSV.z = maxChannel;
    float delta = maxChannel - minChannel;
    if (delta != 0)
    {
        HSV.y = delta / HSV.z;
        float3 delRGB;
        delRGB = (HSV.zzz - RGB + 3 * delta) / (6.0 * delta);
        if (RGB.x == HSV.z) HSV.x = delRGB.z - delRGB.y;
        else if (RGB.y == HSV.z) HSV.x = (1.0 / 3.0) + delRGB.x - delRGB.z;
        else if (RGB.z == HSV.z) HSV.x = (2.0 / 3.0) + delRGB.y - delRGB.x;
    }

    return HSV;
}

[numthreads(1, 1, 1)]
void CSInit(uint3 id : SV_DispatchThreadID)
{
    ColorCounter[0] = 0;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x < StartX || id.x >= EndX || id.y < StartY || id.y >= EndY)
    {
        return;
    }

    float4 color = InputImage[id.xy];
    float3 hsv = rgb_to_hsv_no_clip(color.rgb);

    const float hue = hsv.x * 360.0f;
    const float saturation = hsv.y;
    const float value = hsv.z;

    // Dark or unsaturated colors are meh.
    // Random hard-coded values.
    if (value < 0.2 || saturation < 0.3)
    {
        return;
    }

    int difference = abs(Hue - hue);
    if (difference > 180)
    {
        difference = 360 - difference;
    }

    if (difference <= HueThreshold)
    {
        InputImage[id.xy] = InRangeColor;
        InterlockedAdd(ColorCounter[0], 1);
    }
}